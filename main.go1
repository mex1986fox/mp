package main

import (
	"fmt"
	"net/http"

	"github.com/gorilla/websocket"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)

func addConnection(response http.ResponseWriter, request *http.Request) {
	sessionID := request.URL.Query().Get("session_id")
	userID := request.URL.Query().Get("user_id")

	//  сходить на сервер проверить авторизацию и аутентификацию по номеру сессии
	client := &http.Client{}
	req, err := http.NewRequest(
		"GET", "http://drovito.ru/api/authentication/users?user_id="+userID, nil,
	)
	// добавляем заголовки
	req.Header.Add("Accept", "text/html")
	req.Header.Add("User-Agent", "MSIE/15.0")
	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("Cookie", "PHPSESSID="+sessionID+";")
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer resp.Body.Close()

	// если статус ответа 200 т.е. пользователь авторизован и аутентифицирован
	// и если для данного юзера не создано подключение к соккету
	// создаем новое подключение к сокету
	if int16(resp.StatusCode) == 200 && connects[userID] == nil {
		fmt.Println("USER AUTENTIFICATION")
		connection, err := upgrader.Upgrade(response, request, nil)
		if err != nil {
			fmt.Println(err)
		}
		// помещаем подключение к сокету в коллекцию
		connects[userID] = connection

		// запускаем опросник сообщений
		// нужно опрашивать базу каждые 3 секунды
		// и производить новую запись выбранную из базы в объект сокетта
		// если старая запись отличается от новой по битовой маске
		// тогда отправлять новую запись пользователю
		// а старую заменять новой
		// запись примерно такая
		// recipients[
		// 	id_users_recipient[
		// 		id_user_sender: amount_messages,
		// 		id_user_sender: amount_messages
		// 		id_user_sender: amount_messages
		// 	],
		// 	id_users_recipient[
		// 		id_user_sender: amount_messages,
		// 		id_user_sender: amount_messages
		// 		id_user_sender: amount_messages
		// 	]
		// ]

		// for {
		// 	conn := connect.conn
		// 	messageType, message, err := conn.ReadMessage()
		// 	if err != nil {
		// 		fmt.Println(err)
		// 		return
		// 	}
		// 	if message != nil {
		// 		fmt.Println(messageType)
		// 		fmt.Println(string(message))
		// 	}

		// 	interval.Start(func() {
		// 		if err := conn.WriteMessage(1, []byte("Gudby")); err != nil {
		// 			fmt.Println(err)
		// 			return
		// 		}
		// 	}, 5*time.Second)

		// }

		fmt.Println("New connection: ", connects)
	}
	fmt.Println("Запрос закончен")

}
func handler(response http.ResponseWriter, request *http.Request) {
	addConnection(response, request)

}

func main() {
	//массив (карта) соединений
	//ключом является id юзера
	var connects = make(map[string]*websocket.Conn)
	// открываем соединение
	session, err := mgo.Dial("mongodb://127.0.0.1:27017")
	if err != nil {
		panic(err)
	}
	defer session.Close()

	// получаем коллекцию диалогов
	type Dialog struct {
		apponentID string `bson:"apponent_id"`
		dialogID   string `bson:"dialog_id"`
	}
	dialogsCollection := session.DB("messages").C("dialogs")

	query := bson.M{"_id": userID}
	// объект для сохранения результата
	products := []Product{}
	productCollection.Find(query).All(&products)

	for _, p := range products {

		fmt.Println(p.Model, p.Company, p.Price)
	}

	var upgrader = websocket.Upgrader{
		ReadBufferSize:  1024,
		WriteBufferSize: 1024,
		CheckOrigin: func(r *http.Request) bool {
			return true
		},
	}
	// запрос такого плана /ws?user_id=1?session_id=dfdfg23d
	http.HandleFunc("/ws", handler)
	fmt.Println("Server started ...")
	err := http.ListenAndServe(":8085", nil)
	if err != nil {
		fmt.Println("ListenAndServer: ", err)
	}

}
